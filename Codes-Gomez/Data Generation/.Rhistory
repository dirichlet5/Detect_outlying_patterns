# Creating a function from a Gaussian Process
T = 50 #Number of observations (Equidistant grid)
t = seq(0,1,length=T)
E = as.matrix(dist(t, diag=TRUE, upper=TRUE))
View(E)
Sigma = exp(-10*E^2)
eig = eigen(Sigma)
Sigma.sqrt = eig$vec%*%diag(sqrt(eig$val+10^(-10)))%*%t(eig$vec)
View(Sigma)
View(Sigma.sqrt)
mean1 = Sigma.sqrt%*%rnorm(n)
mean1 = Sigma.sqrt%*%rnorm(T)
plot(mean1)
eig_noise = eigen(S_noise)
S_noise = exp(-0.1*E^2)
eig_noise = eigen(S_noise)
S.sqrt_noise = eig_noise$vec%*%diag(sqrt(eig_noise$val+10^(-10)))%*%t(eig_noise$vec)
noise = S.sqrt_noise%*%rnorm(T)
signal = mean1 + noise
var = var(signal)
ds1 = sqrt(var/snr)
snr = 20
ds1 = sqrt(var/snr)
S.sqrt_err = diag(T)*drop(ds1)
ds1 = sqrt(var/snr)
S.sqrt_err = diag(T)*drop(ds1)
noise = S.sqrt_noise%*%rnorm(T)
error = S.sqrt_err%*%rnorm(T)
plot(noise)
plot(error)
plot(x1)
x1 = mean1 + noise + error
plot(x1)
#Functional principal components
spb = 10
splinebasis_B = create.bspline.basis(c(0,1),spb)
install.packages("fda")
library(fda)
splinebasis_B = create.bspline.basis(c(0,1),spb)
base_B = eval.basis(as.vector(t),splinebasis_B)
plot(base_B[>,1])
plot(base_B[,1])
plot(base_B[,2])
plot(base_B[,3])
plot(base_B[,4])
smooth = smooth.basis(t,t(x1,splinebasis_B)
smooth = smooth.basis(t,t(x1,splinebasis_B))
smooth = smooth.basis(t,t(x1,splinebasis_B))
smooth = smooth.basis(t,t(x1),splinebasis_B)
smooth = smooth.basis(t,x1,splinebasis_B)
View(smooth)
B = t(smooth$fd$coefs)
obj = smooth$fd
pca = pca.fd(obj, spb)
pca = pca.fd(obj, 2)
# Creating a function from a Gaussian Process
T = 50 #Number of observations (Equidistant grid)
t = seq(0,1,length=T)
E = as.matrix(dist(t, diag=TRUE, upper=TRUE))
Sigma = exp(-10*E^2)
eig = eigen(Sigma)
Sigma.sqrt = eig$vec%*%diag(sqrt(eig$val+10^(-10)))%*%t(eig$vec)
mean1 = Sigma.sqrt%*%rnorm(T)
S_noise = exp(-0.1*E^2)
eig_noise = eigen(S_noise)
S.sqrt_noise = eig_noise$vec%*%diag(sqrt(eig_noise$val+10^(-10)))%*%t(eig_noise$vec)
noise = S.sqrt_noise%*%rnorm(T)
signal = mean1 + noise
var = var(signal)
snr = 20
ds1 = sqrt(var/snr)
S.sqrt_err = diag(T)*drop(ds1)
noise = S.sqrt_noise%*%rnorm(T)
error = S.sqrt_err%*%rnorm(T)
x2 = mean1 + noise + error
#Functional principal components
spb = 10
splinebasis_B = create.bspline.basis(c(0,1),spb)
base_B = eval.basis(as.vector(t),splinebasis_B)
x = cbind(x1,x2)
smooth = smooth.basis(t,t(x),splinebasis_B)
smooth = smooth.basis(t,x,splinebasis_B)
B = t(smooth$fd$coefs)
obj = smooth$fd
pca = pca.fd(obj, 2)
View(pca)
var.pca = cumsum(pca$varprop)
nharm = sum(var.pca < 0.95) + 1
pc = pca.fd(obj, nharm)
View(pc)
plot(pc$harmonics)
lines(x1,type = "l", col = "red")
lines(x2,type = "l", col = "red")
plot (x1)
Sigma = x1%*%t(x1)
ans = eigen(Sigma)
View(ans)
values
plot(ans$values)
plot(ans$vectors[,1])
plot(ans$vectors[1,])
plot(ans$vectors[,1])
plot(ans$vectors[,2])
plot(ans$vectors[,3])
plot(ans$vectors[,4])
plot(ans$vectors[,1])
lines(x1)
plot(x1)
